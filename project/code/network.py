# 0 = all messages are logged (default behavior)
# 1 = INFO messages are not printed
# 2 = INFO and WARNING messages are not printed
# 3 = INFO, WARNING, and ERROR messages are not printed
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import numpy as np
import pandas as pd
import collections

from sklearn.model_selection import train_test_split
from sklearn.model_selection import StratifiedKFold

from keras.utils import np_utils 
from keras.models import Sequential
from keras.layers import Dense

from mem import check_mem


class NNetworkManager:

    def __init__(self, path_csv, len_classes):

        self.path_csv = path_csv
        self.len_classes = len_classes

        # self.features = features

    def create_folds(self, n_splits):
        df_ = pd.read_csv(self.path_csv)
        df_ = df_[df_['Size'] > 0] # != 0

        # only for testing
        # df = df.groupby('Class').head(800)

        # check filesize columns
        for i in range(15):
            print(f'Files less than {i}MB')
            
            df = df_[df_['Size'] < i*1024**2] # < 1MB
            aprox_mem = round(df['Size'].sum()/(1024**3), 2) # in GB

            print('  ', df_.shape, df.shape)
            # print(df_.Class.value_counts(), df.Class.value_counts())
            print('  ', aprox_mem, 'GB')
        input()

        X = np.array(df['Id']).reshape(-1, 1) # matriz coluna
        y = np.array(df['Class'])

        skf = StratifiedKFold(
            n_splits = n_splits,
            shuffle = True,
            random_state = 42
        )

        for i, (train_index, test_index) in enumerate(skf.split(X, y)):
            # print(i, '---')
            # print("     TRAIN:", train_index, "TEST:", test_index)
            X_train, X_test = X[train_index], X[test_index]
            y_train, y_test = y[train_index], y[test_index]

            # modify Class to be in the one-hot format
            # 0 -> [1, 0, 0, 0, 0, 0, 0, 0, 0]
            # 1 -> [0, 1, 0, 0, 0, 0, 0, 0, 0]
            # 2 -> [0, 0, 1, 0, 0, 0, 0, 0, 0]

            Y_train = np_utils.to_categorical(y_train, self.len_classes)
            Y_test = np_utils.to_categorical(y_test, self.len_classes)

            yield (i, X_train, X_test, Y_train, Y_test)

    def save_fold(self, path, fold_i, X_train, X_test, Y_train, Y_test):

        print('X_train.shape', X_train.shape)
        print('X_test.shape', X_test.shape)

        ngram = 1 # inject

        dfs = [
            (X_train, 'X_train'), (X_test, 'X_test'),
            (Y_train, 'Y_train'), (Y_test, 'Y_test')
        ]

        for df, df_name in dfs:
            pd.DataFrame(df).to_csv(
                f'{path}/g{ngram}_f{fold_i}_{df_name}.csv', 
                encoding='utf-8'
            )

    def load_fold(self, path, fold_i):

        ngram = 1 # inject

        dfs = [
            'X_train', 'X_test',
            'Y_train', 'Y_test'
        ]

        df_return = []
        for df_name in dfs:
            df_return.append(
                pd.read_csv(
                    f'{path}/g{ngram}_f{fold_i}_{df_name}.csv',
                    index_col = 0
                )
            )

        return df_return


    def fit(self, X_train, X_test, Y_train, Y_test):

        epochs = 50  # inject

        features_len = X_train.shape[1]
        classes_len = Y_train.shape[1]

        # define network
        model = Sequential()
        model.add(Dense(features_len, activation='relu')) # most common for hidden layers
        model.add(Dense(classes_len, activation='sigmoid'))

        # notes for future
        # model.add(Dense(512, input_shape=(784,))) #(784,) is not a typo -- that represents a 784 length vector!
        # model.add(Activation('relu'))

        # compile network
        model.compile(
            loss='binary_crossentropy', 
            optimizer='adam', 
            metrics=['accuracy']
        )

        # fit network
        model.fit(X_train, Y_train, epochs=epochs, verbose=1)

        # evaluate
        # TODO: evaluate by class
        loss, acc = model.evaluate(X_test, Y_test, verbose=None)
        print(f'Test result - Accuracy: {100*acc}%, Loss {loss}')

        return model
